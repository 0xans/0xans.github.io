Introduction to Malware Development: PE Parsing

In the world of Malware Development and Red Teaming, understanding the underlying operating system structures is non-negotiable. One of the most critical structures in Windows is the Portable Executable (PE) format.

Why does this matter? Because if you want to write shellcode or custom loaders that don't rely on Windows APIs (like GetProcAddress), you need to find functions manually.

The PE Structure

The PE format is a data structure that encapsulates the information necessary for the Windows OS loader to manage the wrapped executable code.

Key Components:

DOS Header: The first 64 bytes. Starts with MZ (0x5A4D).

PE Header: Contains the "Signature" (PE\0\0).

Optional Header: Contains the Data Directories, which is where the Export Table lives.

Code Example (C++)

Here is a snippet demonstrating how one might traverse the Process Environment Block (PEB) to find the base address of kernel32.dllâ€”a common technique in shellcode.

#include <windows.h>
#include <iostream>

// Function to get the PEB
PTEB GetTEB() {
    #if defined(_M_X64) 
        return (PTEB)__readgsqword(0x30);
    #else
        return (PTEB)__readfsdword(0x18);
    #endif
}

int main() {
    std::cout << "[*] Parsing PEB to find kernel32..." << std::endl;
    // Implementation details hidden for brevity
    return 0;
}


Stealth Considerations

When developing custom implants, simply calling APIs will get you caught by EDRs (Endpoint Detection and Response). By parsing the PE header manually, we can resolve functions dynamically without leaving static import traces.

Conclusion

This is just the tip of the iceberg. In the next article, we will discuss Direct Syscalls.
